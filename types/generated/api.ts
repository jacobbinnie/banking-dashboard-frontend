/* tslint:disable */
/* eslint-disable */
/**
 * Banking Dashboard Backend API
 * The Banking Dashbaord Backend API description.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountAndBalanceDto
 */
export interface AccountAndBalanceDto {
    /**
     * 
     * @type {string}
     * @memberof AccountAndBalanceDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAndBalanceDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAndBalanceDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountAndBalanceDto
     */
    'balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountAndBalanceDto
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAndBalanceDto
     */
    'usageType'?: AccountAndBalanceDtoUsageTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountAndBalanceDto
     */
    'accountType'?: AccountAndBalanceDtoAccountTypeEnum;
    /**
     * 
     * @type {Array<AccountIdentificationDto>}
     * @memberof AccountAndBalanceDto
     */
    'accountIdentifications'?: Array<AccountIdentificationDto>;
    /**
     * 
     * @type {string}
     * @memberof AccountAndBalanceDto
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAndBalanceDto
     */
    'details'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof AccountAndBalanceDto
     */
    'accountNames'?: Array<object>;
    /**
     * 
     * @type {Array<AccountBalanceDto>}
     * @memberof AccountAndBalanceDto
     */
    'accountBalances'?: Array<AccountBalanceDto>;
    /**
     * 
     * @type {object}
     * @memberof AccountAndBalanceDto
     */
    'consolidatedAccountInformation'?: object;
}

export const AccountAndBalanceDtoUsageTypeEnum = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Other: 'OTHER',
    Unknown: 'UNKNOWN'
} as const;

export type AccountAndBalanceDtoUsageTypeEnum = typeof AccountAndBalanceDtoUsageTypeEnum[keyof typeof AccountAndBalanceDtoUsageTypeEnum];
export const AccountAndBalanceDtoAccountTypeEnum = {
    CashTrading: 'CASH_TRADING',
    CashIncome: 'CASH_INCOME',
    CashPayment: 'CASH_PAYMENT',
    ChargeCard: 'CHARGE_CARD',
    Charges: 'CHARGES',
    Commission: 'COMMISSION',
    CreditCard: 'CREDIT_CARD',
    Current: 'CURRENT',
    EMoney: 'E_MONEY',
    LimitedLiquiditySavingsAccount: 'LIMITED_LIQUIDITY_SAVINGS_ACCOUNT',
    Loan: 'LOAN',
    MarginalLending: 'MARGINAL_LENDING',
    MoneyMarket: 'MONEY_MARKET',
    Mortgage: 'MORTGAGE',
    NonResidentExternal: 'NON_RESIDENT_EXTERNAL',
    Other: 'OTHER',
    Overdraft: 'OVERDRAFT',
    OvernightDeposit: 'OVERNIGHT_DEPOSIT',
    PrepaidCard: 'PREPAID_CARD',
    Salary: 'SALARY',
    Savings: 'SAVINGS',
    Settlement: 'SETTLEMENT',
    Tax: 'TAX',
    Unknown: 'UNKNOWN'
} as const;

export type AccountAndBalanceDtoAccountTypeEnum = typeof AccountAndBalanceDtoAccountTypeEnum[keyof typeof AccountAndBalanceDtoAccountTypeEnum];

/**
 * 
 * @export
 * @interface AccountBalanceDto
 */
export interface AccountBalanceDto {
    /**
     * 
     * @type {string}
     * @memberof AccountBalanceDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountBalanceDto
     */
    'dateTime'?: string;
    /**
     * 
     * @type {BalanceAmountDto}
     * @memberof AccountBalanceDto
     */
    'balanceAmount'?: BalanceAmountDto;
    /**
     * 
     * @type {boolean}
     * @memberof AccountBalanceDto
     */
    'creditLineIncluded'?: boolean;
    /**
     * 
     * @type {Array<CreditLineDto>}
     * @memberof AccountBalanceDto
     */
    'creditLines'?: Array<CreditLineDto>;
}
/**
 * 
 * @export
 * @interface AccountIdentificationDto
 */
export interface AccountIdentificationDto {
    /**
     * 
     * @type {string}
     * @memberof AccountIdentificationDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountIdentificationDto
     */
    'identification'?: string;
}
/**
 * 
 * @export
 * @interface AccountTransactionDto
 */
export interface AccountTransactionDto {
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionDto
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionDto
     */
    'bookingDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionDto
     */
    'valueDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionDto
     */
    'status'?: AccountTransactionDtoStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof AccountTransactionDto
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionDto
     */
    'currency'?: string;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'transactionAmount'?: object;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'grossAmount'?: object;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'currencyExchange'?: object;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'chargeDetails'?: object;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionDto
     */
    'reference'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof AccountTransactionDto
     */
    'statementReferences'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionDto
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountTransactionDto
     */
    'transactionInformation'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'addressDetails'?: object;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'isoBankTransactionCode'?: object;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'proprietaryBankTransactionCode'?: object;
    /**
     * 
     * @type {TransactionBalanceDto}
     * @memberof AccountTransactionDto
     */
    'balance'?: TransactionBalanceDto;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'payeeDetails'?: object;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'payerDetails'?: object;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'merchant'?: object;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'enrichment'?: object;
    /**
     * 
     * @type {object}
     * @memberof AccountTransactionDto
     */
    'supplementaryData'?: object;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionDto
     */
    'transactionMutability'?: string;
}

export const AccountTransactionDtoStatusEnum = {
    Booked: 'BOOKED',
    Pending: 'PENDING'
} as const;

export type AccountTransactionDtoStatusEnum = typeof AccountTransactionDtoStatusEnum[keyof typeof AccountTransactionDtoStatusEnum];

/**
 * 
 * @export
 * @interface AccountTransactionsDto
 */
export interface AccountTransactionsDto {
    /**
     * 
     * @type {Array<AccountTransactionDto>}
     * @memberof AccountTransactionsDto
     */
    'transactions': Array<AccountTransactionDto>;
}
/**
 * 
 * @export
 * @interface AccountsAndBalancesDto
 */
export interface AccountsAndBalancesDto {
    /**
     * 
     * @type {Array<AccountAndBalanceDto>}
     * @memberof AccountsAndBalancesDto
     */
    'accounts': Array<AccountAndBalanceDto>;
}
/**
 * 
 * @export
 * @interface BalanceAmountDto
 */
export interface BalanceAmountDto {
    /**
     * 
     * @type {number}
     * @memberof BalanceAmountDto
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof BalanceAmountDto
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface CreditLineDto
 */
export interface CreditLineDto {
    /**
     * 
     * @type {boolean}
     * @memberof CreditLineDto
     */
    'included'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreditLineDto
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreditLineDto
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface InitiateConnectDto
 */
export interface InitiateConnectDto {
    /**
     * 
     * @type {string}
     * @memberof InitiateConnectDto
     */
    'applicationUserId': string;
    /**
     * 
     * @type {string}
     * @memberof InitiateConnectDto
     */
    'institutionId': string;
}
/**
 * 
 * @export
 * @interface TotalRunwayDto
 */
export interface TotalRunwayDto {
    /**
     * 
     * @type {number}
     * @memberof TotalRunwayDto
     */
    'totalRunway': number;
    /**
     * 
     * @type {number}
     * @memberof TotalRunwayDto
     */
    'monthlyBurn': number;
    /**
     * 
     * @type {number}
     * @memberof TotalRunwayDto
     */
    'monthlyIncoming': number;
    /**
     * 
     * @type {number}
     * @memberof TotalRunwayDto
     */
    'monthlyOutgoing': number;
    /**
     * 
     * @type {number}
     * @memberof TotalRunwayDto
     */
    'currentBalance': number;
}
/**
 * 
 * @export
 * @interface TransactionBalanceDto
 */
export interface TransactionBalanceDto {
    /**
     * 
     * @type {number}
     * @memberof TransactionBalanceDto
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionBalanceDto
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface VerifyConnectDto
 */
export interface VerifyConnectDto {
    /**
     * 
     * @type {string}
     * @memberof VerifyConnectDto
     */
    'authCode': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyConnectDto
     */
    'authState': string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountTransactions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/getAccountTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountsAndBalances: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/getAccountsAndBalances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetMonthlyIncomingTransactions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/getMonthlyIncomingTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetMonthlyOutgoingTransactions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/getMonthlyOutgoingTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetTotalRunwayInMonths: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/getTotalRunwayInMonths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InitiateConnectDto} initiateConnectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerInitiateConnectAccount: async (initiateConnectDto: InitiateConnectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initiateConnectDto' is not null or undefined
            assertParamExists('accountsControllerInitiateConnectAccount', 'initiateConnectDto', initiateConnectDto)
            const localVarPath = `/accounts/initiateConnectAccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateConnectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VerifyConnectDto} verifyConnectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerVerifyConnect: async (verifyConnectDto: VerifyConnectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyConnectDto' is not null or undefined
            assertParamExists('accountsControllerVerifyConnect', 'verifyConnectDto', verifyConnectDto)
            const localVarPath = `/accounts/verifyConnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyConnectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetAccountTransactions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountTransactionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetAccountTransactions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetAccountTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetAccountsAndBalances(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAndBalancesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetAccountsAndBalances(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetAccountsAndBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetMonthlyIncomingTransactions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountTransactionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetMonthlyIncomingTransactions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetMonthlyIncomingTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetMonthlyOutgoingTransactions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountTransactionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetMonthlyOutgoingTransactions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetMonthlyOutgoingTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetTotalRunwayInMonths(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TotalRunwayDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetTotalRunwayInMonths(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetTotalRunwayInMonths']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {InitiateConnectDto} initiateConnectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerInitiateConnectAccount(initiateConnectDto: InitiateConnectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerInitiateConnectAccount(initiateConnectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerInitiateConnectAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {VerifyConnectDto} verifyConnectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerVerifyConnect(verifyConnectDto: VerifyConnectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerVerifyConnect(verifyConnectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerVerifyConnect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountTransactions(options?: any): AxiosPromise<AccountTransactionsDto> {
            return localVarFp.accountsControllerGetAccountTransactions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountsAndBalances(options?: any): AxiosPromise<AccountsAndBalancesDto> {
            return localVarFp.accountsControllerGetAccountsAndBalances(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetMonthlyIncomingTransactions(options?: any): AxiosPromise<AccountTransactionsDto> {
            return localVarFp.accountsControllerGetMonthlyIncomingTransactions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetMonthlyOutgoingTransactions(options?: any): AxiosPromise<AccountTransactionsDto> {
            return localVarFp.accountsControllerGetMonthlyOutgoingTransactions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetTotalRunwayInMonths(options?: any): AxiosPromise<TotalRunwayDto> {
            return localVarFp.accountsControllerGetTotalRunwayInMonths(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InitiateConnectDto} initiateConnectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerInitiateConnectAccount(initiateConnectDto: InitiateConnectDto, options?: any): AxiosPromise<string> {
            return localVarFp.accountsControllerInitiateConnectAccount(initiateConnectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VerifyConnectDto} verifyConnectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerVerifyConnect(verifyConnectDto: VerifyConnectDto, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerVerifyConnect(verifyConnectDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetAccountTransactions(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetAccountTransactions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetAccountsAndBalances(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetAccountsAndBalances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetMonthlyIncomingTransactions(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetMonthlyIncomingTransactions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetMonthlyOutgoingTransactions(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetMonthlyOutgoingTransactions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetTotalRunwayInMonths(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetTotalRunwayInMonths(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InitiateConnectDto} initiateConnectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerInitiateConnectAccount(initiateConnectDto: InitiateConnectDto, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerInitiateConnectAccount(initiateConnectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VerifyConnectDto} verifyConnectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerVerifyConnect(verifyConnectDto: VerifyConnectDto, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerVerifyConnect(verifyConnectDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appControllerGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: any): AxiosPromise<string> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetHello(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }
}



